<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Song Cloud</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* @font-face rules for New Spirit */
        @font-face {
            font-family: 'New Spirit';
            src: url('./fonts/NewSpirit-Regular.woff2') format('woff2'),
                 url('./fonts/NewSpirit-Regular.woff') format('woff');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'New Spirit';
            src: url('./fonts/NewSpirit-Medium.woff2') format('woff2'),
                 url('./fonts/NewSpirit-Medium.woff') format('woff');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            cursor: none;
        }

         #backgroundvideo {
            position: fixed;
            right: 0;
            bottom: 0;
            min-width: 100%;
            min-height: 100%;
            z-index: -1; 
            opacity: 0.2;
            object-fit: cover; /* Ensures video covers screen without stretching */
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            opacity: 0;
            transition: opacity 1s ease;
        }

        /* Custom Cursor */
        #custom-cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none; 
            left: 0;
            top: 0;
            transform: translate(-15px, -15px);
            transition: width 0.1s ease, height 0.1s ease, transform 0.1s ease;
            z-index: 9999;
        }
        #custom-cursor.clicked {
            width: 20px;
            height: 20px;
            transform: translate(-10px, -10px);
        }

        /* Info Panel - New Design */
        #info-panel {
            position: fixed;
            bottom: 48px;
            left: 48px;
            width: auto;
            min-width: 280px;
            max-width: 400px;
            z-index: 100;
            display: none;
            background: transparent;
            border: none;
            box-shadow: none;
        }

        #info-panel.visible {
            display: block;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .now-playing-label {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 16px;
            font-weight: 400;
            color: #ffffff;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .song-title {
            font-family: 'New Spirit', Georgia, serif;
            font-size: 48px;
            font-weight: 500;
            color: #ffffff;
            line-height: 1.1;
            margin: 0;
            letter-spacing: -0.02em;
        }

        .artist-name {
            font-family: 'New Spirit', Georgia, serif;
            font-size: 48px;
            font-weight: 500;
            color: #ffffff;
            line-height: 1.1;
            margin: 0 0 16px 0;
            opacity: 0.7;
            letter-spacing: -0.02em;
        }

        .song-meta {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 20px;
            font-weight: 400;
            color: #ffffff;
            opacity: 0.6;
        }

        .song-meta span {
            margin-right: 8px;
        }

        .meta-separator {
            opacity: 0.4;
            margin: 0 8px;
        }

        /* Filter Dropdown Styles */
        .filter-select {
            min-width: 120px;
            background-color: #1f2937;
            color: #d1d5db;
            border: 1px solid #4b5563;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
        }
        
        #info-panel, #info-panel *, 
        #genre-filter-container, #genre-filter-container *,
        .filter-select {
            cursor: auto;
        }
        
        .genre-btn {
            cursor: pointer;
        }

        /* Genre Grid Styles */
        .genre-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-width: 240px;
        }

        .genre-btn {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 13px;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .genre-btn:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        .genre-btn.active {
            color: #fff;
        }

        /* Genre-specific border hints (not selected) */
        .genre-btn[data-genre="Pop"] {
            border-color: rgba(0, 170, 255, 0.4);
        }
        .genre-btn[data-genre="Rock"] {
            border-color: rgba(255, 68, 0, 0.4);
        }
        .genre-btn[data-genre="Hip Hop"] {
            border-color: rgba(204, 179, 51, 0.4);
        }
        .genre-btn[data-genre="Electronic"] {
            border-color: rgba(0, 255, 170, 0.4);
        }
        .genre-btn[data-genre="Classical"] {
            border-color: rgba(230, 230, 230, 0.4);
        }
        .genre-btn[data-genre="Jazz"] {
            border-color: rgba(204, 0, 204, 0.4);
        }

        /* Genre-specific colors (selected) - muted */
        .genre-btn[data-genre="Pop"].active {
            background: rgba(0, 170, 255, 0.25);
            border-color: rgba(0, 170, 255, 0.7);
        }
        .genre-btn[data-genre="Rock"].active {
            background: rgba(255, 68, 0, 0.25);
            border-color: rgba(255, 68, 0, 0.7);
        }
        .genre-btn[data-genre="Hip Hop"].active {
            background: rgba(204, 179, 51, 0.25);
            border-color: rgba(204, 179, 51, 0.7);
        }
        .genre-btn[data-genre="Electronic"].active {
            background: rgba(0, 255, 170, 0.25);
            border-color: rgba(0, 255, 170, 0.7);
        }
        .genre-btn[data-genre="Classical"].active {
            background: rgba(230, 230, 230, 0.25);
            border-color: rgba(230, 230, 230, 0.7);
        }
        .genre-btn[data-genre="Jazz"].active {
            background: rgba(204, 0, 204, 0.25);
            border-color: rgba(204, 0, 204, 0.7);
        }

        /* Year Range Slider Styles */
        #year-slider-container {
            cursor: auto;
            display: flex;
            align-items: stretch;
        }

        .year-slider-track-container {
            padding: 8px 0;
            display: flex;
            align-items: stretch;
        }

        .year-slider-track {
            position: relative;
            width: 4px;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .year-slider-range {
            position: absolute;
            width: 100%;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 2px;
            pointer-events: none;
        }

        .year-slider-handle {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: grab;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            z-index: 2;
        }

        .year-slider-handle:hover {
            transform: translateX(-50%) scale(1.2);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .year-slider-handle:active {
            cursor: grabbing;
            transform: translateX(-50%) scale(1.1);
        }

        .year-slider-handle.dragging {
            cursor: grabbing;
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        .year-decade-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            padding: 8px 0;
        }

        .decade-label {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.3);
            text-align: right;
            transition: color 0.2s ease, opacity 0.2s ease;
        }

        .decade-label.active {
            color: rgba(255, 255, 255, 1);
        }

        /* Start Screen Overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10000;
            cursor: auto;
            transition: opacity 0.5s ease;
        }

        /* Loading Screen */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 10001;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.5s ease;
        }

        .loading-text {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 24px;
        }

        .loading-dot {
            opacity: 0;
            animation: dotFade 1.5s infinite;
        }

        .loading-dot:nth-child(2) {
            animation-delay: 0.3s;
        }

        .loading-dot:nth-child(3) {
            animation-delay: 0.6s;
        }

        @keyframes dotFade {
            0%, 20% { opacity: 0; }
            40%, 100% { opacity: 1; }
        }

        .loading-animation-placeholder {
            width: 48px;
            height: 48px;
            
        }

        .start-title {
            font-family: 'New Spirit', Georgia, serif;
            font-size: 72px;
            font-weight: 500;
            color: #ffffff;
            letter-spacing: -0.02em;
            margin-bottom: 16px;
        }

        .start-subtitle {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 18px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 48px;
        }

        #start-button {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            background-color: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.7);
            padding: 12px 32px;
            border-radius: 99px;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
        }

        #start-button:hover {
            background-color: rgba(255, 255, 255, 0.35);
            border-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <!-- Start Screen -->
    <div id="start-overlay">
        <h1 class="start-title">Tuneiverse</h1>
        <p class="start-subtitle">Explore music in a new way. Each song leads to others with similar attributes.</p>
        <button id="start-button">Enter</button>
    </div>

    <!-- Loading Screen -->
    <div id="loading-overlay">
        <p class="loading-text">Fetching songs<span class="loading-dot">.</span><span class="loading-dot">.</span><span class="loading-dot">.</span></p>
        <div class="loading-animation-placeholder">
            <img src="Comp 1.gif">
        </div>
    </div>

                <video autoplay muted loop id="backgroundvideo">
        <source src="Halftone Animation.mp4" type="video/mp4">
    </video>

    <!-- Three.js Canvas Container -->
    <div id="container"></div>

    <!-- Custom Cursor element -->
    <div id="custom-cursor"></div>

    <!-- Hidden audio player for Deezer previews -->
    <audio id="song-preview-player" preload="auto"></audio>

    <!-- Info Panel - New Design -->
    <div id="info-panel">
        <p class="now-playing-label">Now Playing</p>
        <h2 id="panel-title" class="song-title">Song Title</h2>
        <p id="panel-artist" class="artist-name">Artist Name</p>
        <p class="song-meta">
            <span id="panel-genre">Genre</span>
            <span class="meta-separator">â€¢</span>
            <span id="panel-year">Year</span>
        </p>
    </div>
    
    <!-- Filter controls - top right -->
    <div id="genre-filter-container" class="fixed text-white z-10" style="top: 48px; right: 48px;">
        <div class="genre-grid">
            <button class="genre-btn active" data-genre="Pop">Pop</button>
            <button class="genre-btn active" data-genre="Rock">Rock</button>
            <button class="genre-btn active" data-genre="Hip Hop">Hip Hop</button>
            <button class="genre-btn active" data-genre="Electronic">Electronic</button>
            <button class="genre-btn active" data-genre="Classical">Classical</button>
            <button class="genre-btn active" data-genre="Jazz">Jazz</button>
        </div>
    </div>

    <!-- Logo - top left -->
    <div class="fixed flex items-center space-x-2 z-10" style="top: 48px; left: 48px;">
        <div style="width: 24px; height: 24px;">
            <img src="Group 1.png">
        </div>
        <span style="font-family: 'New Spirit', Georgia, serif; font-size: 20px; font-weight: 500; color: #ffffff;">Tuneiverse</span>
    </div>

    <!-- Year Range Slider - right side -->
    <div id="year-slider-container" class="fixed z-10 flex items-center space-x-3" style="top: 180px; right: 60px; bottom: 120px;">
        <div class="year-decade-labels">
            <span class="decade-label" data-decade="2020">20s</span>
            <span class="decade-label" data-decade="2010">10s</span>
            <span class="decade-label" data-decade="2000">00s</span>
            <span class="decade-label" data-decade="1990">90s</span>
            <span class="decade-label" data-decade="1980">80s</span>
            <span class="decade-label" data-decade="1970">70s</span>
            <span class="decade-label" data-decade="1960">60s</span>
            <span class="decade-label" data-decade="1950">50s</span>
        </div>
        <div class="year-slider-track-container">
            <div id="year-slider-track" class="year-slider-track">
                <div id="year-slider-range" class="year-slider-range"></div>
                <div id="year-slider-handle-max" class="year-slider-handle" data-handle="max"></div>
                <div id="year-slider-handle-min" class="year-slider-handle" data-handle="min"></div>
            </div>
        </div>
    </div>

    <!-- Speaker Icon - bottom right -->
    <img src="speaker-icon.png" alt="Audio" id="speaker-icon" class="fixed" style="bottom: 48px; right: 60px; width: 24px; height: 24px; cursor: pointer; z-index: 10; opacity: 1; transition: opacity 0.2s ease;">

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let particles;
        let mockData = [];

        let connectionLines;
        let glowSprite;
        let selectedParticleIndex = -1;

        let audioContext;
        let audioPlayer;
        let audioEnabled = true;

        let selectedGenres = new Set(['Pop', 'Rock', 'Hip Hop', 'Electronic', 'Classical', 'Jazz']);
        
        // Year slider state
        const YEAR_MIN = 1950;
        const YEAR_MAX = 2029;
        let yearRangeMin = YEAR_MIN;
        let yearRangeMax = YEAR_MAX;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const SPHERE_RADIUS = 25;

        let mouseX = 0;
        let mouseY = 0;
        let cursorX = 0;
        let cursorY = 0;
        const smoothingFactor = 0.2;

        const container = document.getElementById('container');
        const infoPanel = document.getElementById('info-panel');
        const panelTitle = document.getElementById('panel-title'); 
        const panelArtist = document.getElementById('panel-artist');
        const panelGenre = document.getElementById('panel-genre');
        const panelYear = document.getElementById('panel-year');
        const customCursor = document.getElementById('custom-cursor');
        const filterBox = document.getElementById('genre-filter-container');
        const yearSliderContainer = document.getElementById('year-slider-container');
        const speakerIcon = document.getElementById('speaker-icon');
        
        const genres = ['Pop', 'Rock', 'Hip Hop', 'Electronic', 'Classical', 'Jazz'];
        const genreColors = {
            'Pop': new THREE.Color(0x00aaff),
            'Rock': new THREE.Color(0xff4400),
            'Hip Hop': new THREE.Color(0.8, 0.7, 0.2),
            'Electronic': new THREE.Color(0x00ffaa),
            'Classical': new THREE.Color(0.9, 0.9, 0.9),
            'Jazz': new THREE.Color(0.8, 0.0, 0.8)
        };

        const genreNotes = {
            'Pop': 1046.50,
            'Rock': 1046.50,
            'Hip Hop': 1046.50,
            'Electronic': 1046.50,
            'Classical': 1046.50,
            'Jazz': 1046.50
        };

        function getRandomPointInSphere(radius) {
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = radius * Math.cbrt(Math.random());
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        async function getSpotifyData() {
            const YOUR_BACKEND_TOKEN_URL = 'http://localhost:3000/api/get-spotify-token';
            let processedData = []; 

            try {
                console.log("Attempting to fetch Spotify token from backend...");
                const tokenResponse = await fetch(YOUR_BACKEND_TOKEN_URL);
                if (!tokenResponse.ok) {
                    throw new Error(`Backend token server responded with ${tokenResponse.status}. (Is server.js running?)`);
                }
                const tokenData = await tokenResponse.json();
                const accessToken = tokenData.access_token;
                console.log("Successfully fetched token from backend.");
                
                console.log("Fetching real data for multiple genres...");
                
                for (const genre of genres) {
                    for (const offset of [0, 50, 100, 150]) {
                        const searchQuery = `genre:${genre.toLowerCase()}`;
                        const SPOTIFY_SEARCH_URL = `https://api.spotify.com/v1/search?q=${encodeURIComponent(searchQuery)}&type=track&limit=50&offset=${offset}`;

                        const spotifyResponse = await fetch(SPOTIFY_SEARCH_URL, {
                            headers: { 'Authorization': `Bearer ${accessToken}` }
                        });

                        if (!spotifyResponse.ok) {
                            console.warn(`Spotify API request failed for ${genre} (offset ${offset}): ${spotifyResponse.status}`);
                            continue; 
                        }
                        
                        const spotifyData = await spotifyResponse.json();
                        
                        const tracks = spotifyData.tracks.items.map(track => {
                            if (!track || !track.album || !track.artists) return null; 
                            
                            const assignedGenre = genre; 
                            const year = new Date(track.album.release_date).getFullYear() || 2000;
                            const trackName = track.name;
                            const artistName = track.artists[0].name;
                            
                            return {
                                position: getRandomPointInSphere(SPHERE_RADIUS),
                                color: genreColors[assignedGenre] || new THREE.Color(0xffffff), 
                                data: {
                                    genre: assignedGenre, 
                                    year: year,
                                    songs: [`${trackName} by ${artistName}`, `Album: ${track.album.name}`],
                                    trackName: trackName,
                                    artistName: artistName,
                                    previewUrl: 'unfetched' 
                                }
                            };
                        }).filter(track => track !== null);
                        
                        processedData.push(...tracks);
                    }
                }
                
                console.log(`Successfully fetched ${processedData.length} real tracks from Spotify.`);
                
                if (processedData.length === 0) {
                    throw new Error("No tracks were processed.");
                }
                return processedData;

            } catch (error) {
                console.warn(`API fetch failed: ${error.message}. Using mock data instead.`);
                return generateMockData(2000);
            }
        }
        
        function generateMockData(count) {
            const data = [];
            for (let i = 0; i < count; i++) {
                const genre = genres[Math.floor(Math.random() * genres.length)];
                const year = 1980 + Math.floor(Math.random() * 45);
                const songName = `${genre} Song #${Math.floor(Math.random() * 100)}`;
                const artistName = "Mock Artist";
                
                data.push({
                    position: getRandomPointInSphere(SPHERE_RADIUS),
                    color: genreColors[genre],
                    data: { 
                        genre: genre, 
                        year: year, 
                        songs: [`${songName} by ${artistName}`, `Album: ${genre} Hits (${year})`],
                        trackName: songName,
                        artistName: artistName,
                        previewUrl: 'unfetched'
                    }
                });
            }
            return data;
        }

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.008); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = SPHERE_RADIUS * 1.2; 

           renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setClearColor( 0x000000, 0 ); // Explicitly set background to transparent
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            container.style.opacity = 1;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.minDistance = 5; 
            controls.maxDistance = SPHERE_RADIUS + 30; 

            console.log("Loading song data...");
            mockData = await getSpotifyData(); 
            console.log(`Data loaded. ${mockData.length} particles will be created.`);
            
            populateFilters();
            initYearSlider();
            initGenreButtons();

            console.log("Creating particles...");
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            mockData.forEach(item => {
                positions.push(item.position.x, item.position.y, item.position.z);
                colors.push(item.color.r, item.color.g, item.color.b);
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const softDotTexture = createSoftDotTexture();

            const material = new THREE.PointsMaterial({
                size: 1.0,
                map: softDotTexture,
                vertexColors: true, 
                transparent: true,
                blending: THREE.AdditiveBlending, 
                depthWrite: false 
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            const glowTexture = createGlowTexture();
            const spriteMaterial = new THREE.SpriteMaterial({
                map: glowTexture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.9,
                depthWrite: false
            });
            glowSprite = new THREE.Sprite(spriteMaterial);
            glowSprite.scale.set(6, 6, 1);
            glowSprite.visible = false;
            particles.add(glowSprite); 

            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.4,
                depthWrite: false
            });
            const lineGeometry = new THREE.BufferGeometry();
            connectionLines = new THREE.LineSegments(lineGeometry, lineMaterial);
            particles.add(connectionLines);

            window.addEventListener('resize', onWindowResize);
            container.addEventListener('mousedown', onMouseDown);
            
            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            window.addEventListener('mousedown', () => {
                customCursor.classList.add('clicked');
            });
            window.addEventListener('mouseup', () => {
                customCursor.classList.remove('clicked');
            });

            [infoPanel, filterBox, yearSliderContainer, speakerIcon].forEach(el => {
                el.addEventListener('mouseenter', () => {
                    customCursor.style.display = 'none';
                });
                el.addEventListener('mouseleave', () => {
                    customCursor.style.display = 'block';
                });
            });

            // Speaker icon toggle
            speakerIcon.addEventListener('click', () => {
                audioEnabled = !audioEnabled;
                speakerIcon.style.opacity = audioEnabled ? '1' : '0.3';
                
                if (!audioEnabled && audioPlayer && !audioPlayer.paused) {
                    audioPlayer.pause();
                } else if (audioEnabled && selectedParticleIndex !== -1) {
        // Resume audio when unmuted
        const particleData = mockData[selectedParticleIndex].data;
        playSound(particleData);
    }
            });
            
            // Genre filter is now handled by initGenreButtons()
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!particles) return;
            
            if (particles) {
                if (!controls.autoRotate) {
                    particles.rotation.y += 0.0002;
                    particles.rotation.x += 0.0001;
                }
            }

            controls.update(); 
            
            cursorX += (mouseX - cursorX) * smoothingFactor;
            cursorY += (mouseY - cursorY) * smoothingFactor;
            customCursor.style.left = `${cursorX}px`;
            customCursor.style.top = `${cursorY}px`;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(event) {
            if (infoPanel.contains(event.target) || filterBox.contains(event.target)) {
                return;
            }

            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            raycaster.params.Points.threshold = 0.5; 

            const objectsToIntersect = [particles];
            if (glowSprite.visible) {
                objectsToIntersect.push(glowSprite);
            }
            const intersects = raycaster.intersectObjects(objectsToIntersect);

            if (intersects.length > 0) {
                if (intersects[0].object === glowSprite) {
                    return;
                }
                const particleIntersect = intersects.find(hit => hit.object === particles);
                if (!particleIntersect) {
                    return;
                }
                const index = particleIntersect.index;
                if (index === selectedParticleIndex) {
                    return;
                }

                // NEW: Check if the particle is visible (not faded out)
                const particleData = mockData[index].data;
                const genreMatch = selectedGenres.has(particleData.genre);
                const yearMatch = particleData.year >= yearRangeMin && particleData.year <= yearRangeMax;
                
                if (!genreMatch || !yearMatch) {
                    return; // Don't select faded particles
                }

                showInfoPanel(particleData);
                showGlow(index);
                updateConnectionLines(index);
                selectedParticleIndex = index;

                playSound(particleData);
            } 
        }

        function showInfoPanel(data) {
            if (data.songs && data.songs.length > 0) {
                const songLine = data.songs[0];
                const parts = songLine.split(' by ');
                
                if (parts.length === 2) {
                    panelTitle.textContent = parts[0];
                    panelArtist.textContent = parts[1];
                } else {
                    panelTitle.textContent = songLine;
                    panelArtist.textContent = '';
                }
            } else {
                panelTitle.textContent = 'Unknown Track';
                panelArtist.textContent = 'Unknown Artist';
            }
            
            panelGenre.textContent = data.genre || 'Unknown';
            panelYear.textContent = data.year || '----';
            
            infoPanel.classList.add('visible');
            infoPanel.style.display = 'block';
        }

        function hideInfoPanel() {
            infoPanel.classList.remove('visible');
            infoPanel.style.display = 'none';
            
            if (audioPlayer && !audioPlayer.paused) {
                audioPlayer.pause();
            }
        }

        async function fetchAndCacheDeezerPreview(particleData) {
            const { trackName, artistName } = particleData;
            const url = `http://localhost:3000/api/get-deezer-preview?track=${encodeURIComponent(trackName)}&artist=${encodeURIComponent(artistName)}`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Backend preview server error: ${response.status}`);
                }
                const data = await response.json();
                
                particleData.previewUrl = data.previewUrl || null; 
                return particleData.previewUrl;
                
            } catch (error) {
                console.error("Failed to fetch preview from backend:", error.message);
                particleData.previewUrl = null;
                return null;
            }
        }

        async function playSound(data) { 
            if (!audioEnabled) return; // Don't play if audio is disabled
            
            if (audioContext && audioContext.state === 'running') {
                 audioContext.suspend(); 
                 audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            let previewUrl = data.previewUrl;
            if (previewUrl === 'unfetched') {
                console.log("First click, fetching Deezer preview...");
                previewUrl = await fetchAndCacheDeezerPreview(data);
            }
            
            if (previewUrl) {
                console.log("Playing preview:", previewUrl);
                audioPlayer.src = previewUrl;
                try {
                    await audioPlayer.play();
                    console.log("Preview started.");
                } catch (err) {
                    console.error("Audio play failed:", err.message);
                    playChimeSound(data);
                }
            } else {
                console.log("No preview URL found. Playing chime sound.");
                playChimeSound(data);
            }
        }

        function playChimeSound(data) { 
            if (!audioContext) {
                console.warn("No AudioContext for chime sound.");
                return;
            }
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            const fundamental = genreNotes[data.genre] || 1046.50; 
            const currentTime = audioContext.currentTime;
            const duration = 2.5;
            const fadeInTime = 0.05;
            const peakVolume = 0.2;

            const mainGain = audioContext.createGain();
            mainGain.gain.setValueAtTime(0.001, currentTime);
            mainGain.gain.exponentialRampToValueAtTime(peakVolume, currentTime + fadeInTime);
            mainGain.gain.exponentialRampToValueAtTime(0.001, currentTime + duration);
            mainGain.connect(audioContext.destination);

            const partials = [
                { freq: fundamental * 1,    volume: 1.0 },
                { freq: fundamental * 2.01, volume: 0.4 },
                { freq: fundamental * 3.15, volume: 0.2 },
                { freq: fundamental * 4.25, volume: 0.1 }
            ];

            partials.forEach((partial) => {
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(partial.freq, currentTime);
                
                const partialGain = audioContext.createGain();
                partialGain.gain.setValueAtTime(partial.volume, currentTime);
                partialGain.gain.exponentialRampToValueAtTime(0.001, currentTime + duration * 0.9);

                osc.connect(partialGain);
                partialGain.connect(mainGain);
                
                osc.start(currentTime);
                osc.stop(currentTime + duration); 
            });
        }

        function showGlow(index) {
            const particle = mockData[index];
            glowSprite.position.copy(particle.position);
            glowSprite.material.color.copy(particle.color);
            glowSprite.visible = true;
        }

        function updateConnectionLines(index) {
            const selectedParticle = mockData[index];
            const selectedPosition = selectedParticle.position;
            const selectedGenre = selectedParticle.data.genre;
            const selectedYear = selectedParticle.data.year;
            
            const linePositions = [];
            let genreTarget = null;
            let yearTarget = null;
            
            const particleColors = particles.geometry.attributes.color;
            const FADED_COLOR = new THREE.Color(0x1a1a1a);

            for (let i = 0; i < mockData.length; i++) {
                if (i === index) continue; 
                
                const isVisible = !(
                    Math.abs(particleColors.getX(i) - FADED_COLOR.r) < 0.01 &&
                    Math.abs(particleColors.getY(i) - FADED_COLOR.g) < 0.01 &&
                    Math.abs(particleColors.getZ(i) - FADED_COLOR.b) < 0.01
                );

                if (isVisible) {
                    const otherParticle = mockData[i];
                    
                    if (!genreTarget && otherParticle.data.genre === selectedGenre) {
                        genreTarget = otherParticle.position;
                    }
                    if (!yearTarget && otherParticle.data.year === selectedYear) {
                        yearTarget = otherParticle.position;
                    }
                    if (genreTarget && yearTarget) {
                        break;
                    }
                }
            }
            
            if (genreTarget) {
                linePositions.push(selectedPosition.x, selectedPosition.y, selectedPosition.z);
                linePositions.push(genreTarget.x, genreTarget.y, genreTarget.z);
            }
            if (yearTarget) {
                linePositions.push(selectedPosition.x, selectedPosition.y, selectedPosition.z);
                linePositions.push(yearTarget.x, yearTarget.y, yearTarget.z);
            }

            connectionLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            connectionLines.geometry.computeBoundingSphere();
        }

        function hideGlowAndLines() {
            glowSprite.visible = false;
            connectionLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
            selectedParticleIndex = -1;
            
            if (audioPlayer && !audioPlayer.paused) {
                audioPlayer.pause();
            }
        }

        function populateFilters() {
            // Genre buttons are now static in HTML
            // This function is kept for potential future use
        }

        function initYearSlider() {
            const track = document.getElementById('year-slider-track');
            const range = document.getElementById('year-slider-range');
            const handleMin = document.getElementById('year-slider-handle-min');
            const handleMax = document.getElementById('year-slider-handle-max');
            const decadeLabels = document.querySelectorAll('.decade-label');
            
            const trackHeight = track.offsetHeight;
            let isDragging = false;
            let activeHandle = null;

            function yearToPercent(year) {
                return ((year - YEAR_MIN) / (YEAR_MAX - YEAR_MIN)) * 100;
            }

            function percentToYear(percent) {
                return Math.round(YEAR_MIN + (percent / 100) * (YEAR_MAX - YEAR_MIN));
            }

            function updateDecadeLabels() {
                decadeLabels.forEach(label => {
                    const decade = parseInt(label.dataset.decade);
                    const decadeEnd = decade + 9;
                    
                    // Check if this decade overlaps with the selected range
                    const isActive = decadeEnd >= yearRangeMin && decade <= yearRangeMax;
                    
                    if (isActive) {
                        label.classList.add('active');
                    } else {
                        label.classList.remove('active');
                    }
                });
            }

            function updateSliderUI() {
                const minPercent = yearToPercent(yearRangeMin);
                const maxPercent = yearToPercent(yearRangeMax);
                
                // Position handles (inverted because top = max year visually)
                handleMin.style.top = `${100 - minPercent}%`;
                handleMax.style.top = `${100 - maxPercent}%`;
                
                // Position range highlight
                range.style.top = `${100 - maxPercent}%`;
                range.style.height = `${maxPercent - minPercent}%`;
                
                // Update decade labels
                updateDecadeLabels();
            }

            function handleDrag(e) {
                if (!isDragging || !activeHandle) return;
                
                e.preventDefault();
                const rect = track.getBoundingClientRect();
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                // Calculate percent (inverted)
                let percent = 100 - ((clientY - rect.top) / rect.height) * 100;
                percent = Math.max(0, Math.min(100, percent));
                
                const year = percentToYear(percent);
                
                if (activeHandle.dataset.handle === 'min') {
                    yearRangeMin = Math.min(year, yearRangeMax - 1);
                } else {
                    yearRangeMax = Math.max(year, yearRangeMin + 1);
                }
                
                updateSliderUI();
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    if (activeHandle) {
                        activeHandle.classList.remove('dragging');
                    }
                    activeHandle = null;
                    
                    // Apply filters when drag ends
                    applyFilters();
                    if (selectedParticleIndex !== -1) {
                        updateConnectionLines(selectedParticleIndex);
                    }
                }
            }

            // Mouse events
            [handleMin, handleMax].forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    activeHandle = handle;
                    handle.classList.add('dragging');
                    e.preventDefault();
                });
                
                handle.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    activeHandle = handle;
                    handle.classList.add('dragging');
                }, { passive: true });
            });

            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('touchmove', handleDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);

            // Initialize UI
            updateSliderUI();
        }

        function applyFilters() {
            if (!particles) return; 

            const colors = particles.geometry.attributes.color;
            const FADED_COLOR = new THREE.Color(0x1a1a1a); 

            for (let i = 0; i < mockData.length; i++) {
                const particle = mockData[i];
                const genreMatch = selectedGenres.has(particle.data.genre);
                const yearMatch = particle.data.year >= yearRangeMin && particle.data.year <= yearRangeMax;

                if (genreMatch && yearMatch) {
                    colors.setXYZ(i, particle.color.r, particle.color.g, particle.color.b);
                } else {
                    colors.setXYZ(i, FADED_COLOR.r, FADED_COLOR.g, FADED_COLOR.b);
                }
            }
            colors.needsUpdate = true;
            
            if (selectedParticleIndex !== -1) {
                const particle = mockData[selectedParticleIndex];
                const genreMatch = selectedGenres.has(particle.data.genre);
                const yearMatch = particle.data.year >= yearRangeMin && particle.data.year <= yearRangeMax;
                
                if (!(genreMatch && yearMatch)) {
                    hideInfoPanel();
                    hideGlowAndLines();
                }
            }
        }

        function initGenreButtons() {
            const genreButtons = document.querySelectorAll('.genre-btn');
            
            genreButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const genre = btn.dataset.genre;
                    
                    // Toggle the genre selection
                    if (selectedGenres.has(genre)) {
                        // Don't allow deselecting if it's the last one
                        if (selectedGenres.size > 1) {
                            selectedGenres.delete(genre);
                            btn.classList.remove('active');
                        }
                    } else {
                        selectedGenres.add(genre);
                        btn.classList.add('active');
                    }
                    
                    // Apply filters
                    applyFilters();
                    if (selectedParticleIndex !== -1) {
                        updateConnectionLines(selectedParticleIndex);
                    }
                });
            });
        }

        function createSoftDotTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function startExperience() {
            const overlay = document.getElementById('start-overlay');
            const loadingOverlay = document.getElementById('loading-overlay');
            
            // Show loading immediately
            loadingOverlay.style.display = 'flex';
            
            // Then fade out start screen
            overlay.style.opacity = 0;
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 500);

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn("Web Audio API is not supported in this browser.");
            }
            
            audioPlayer = document.getElementById('song-preview-player');
            audioPlayer.volume = 0.5;

            audioPlayer.play().catch((e) => {
                if (e.name !== "NotSupportedError") {
                    console.warn("Audio player unlock failed:", e.message);
                }
            });
            audioPlayer.pause();
            
            init().then(() => {
                loadingOverlay.style.opacity = 0;
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 500);
                animate();
            });
        }
        
        document.getElementById('start-button').addEventListener('click', startExperience);

    </script>
</body>
</html>